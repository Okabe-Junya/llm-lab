# Go Implementation Best Practices Style Guide

**Note:** This guide uses **RFC 2119** and **RFC 8174** keywords (MUST, MUST NOT, SHOULD, SHOULD NOT, MAY) to indicate the level of obligation for each rule. It is intended for mid-to-senior Go engineers writing production code, emphasizing consistency, clarity, and maintainability across large codebases.

## Error Handling

- **[MUST]** Always check and handle errors returned by functions. Never ignore an error by assigning to `_` or otherwise discarding it. If a function returns an error, the code **MUST** verify success and either handle the error, return it up the call stack, or (in truly exceptional cases) trigger a panic ([Effective Go - The Go Programming Language](https://go.dev/doc/effective_go#:~:text=Occasionally%20you%27ll%20see%20code%20that,they%27re%20provided%20for%20a%20reason)) ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Handle%20Errors)). **Rationale:** Ignoring errors causes missed failure conditions and unstable behavior.

  ```go
  // Bad Practice: error ignored, could cause a crash if path doesn't exist
  fi, _ := os.Stat(path)            // ignoring error
  fmt.Println(fi.Name())           // will panic if fi is nil on error

  // Good Practice: check the error and handle it or return
  fi, err := os.Stat(path)
  if err != nil {
      return fmt.Errorf("failed to stat file: %w", err)  // propagate with context
  }
  fmt.Println(fi.Name())           // safe to use fi
  ```

- **[MUST NOT]** Use `panic` for handling ordinary errors or expected error conditions ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Don%E2%80%99t%20Panic)). Panics are for unrecoverable conditions or programmer bugs. Instead, return error values for callers to handle. **Example:** A parsing failure should return an `error` rather than panic.

- **[MUST]** Make error messages (the strings in error values) informative but concise, and format them in lower-case without trailing punctuation ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Error%20strings%20should%20not%20be,not%20combined%20inside%20other%20messages)). This ensures errors composed or logged together read naturally. For example, use `fmt.Errorf("failed to load config")` *not* `fmt.Errorf("Failed to load config.")`.

- **[SHOULD]** Prefer **early returns** for error handling to keep code visually linear and avoid deep nesting. Check for error cases and return as needed, so that the normal execution path is not indented inside an `else` block ([Go Code Review Comments · GitHub](https://gist.github.com/adamveld12/c0d9f0d5f0e1fba1e551#:~:text=Try%20to%20keep%20the%20normal,For%20instance%2C%20don%27t%20write)) ([Go Code Review Comments · GitHub](https://gist.github.com/adamveld12/c0d9f0d5f0e1fba1e551#:~:text=Instead%2C%20write%3A)). This makes code easier to follow by allowing the successful flow to proceed with minimal indentation.

  ```go
  // Bad: normal path is nested inside an else
  if err := doWork(); err != nil {
      log.Errorf("Work failed: %v", err)
  } else {
      finishWork()    // normal path indented in else
  }

  // Good: return on error, then proceed with normal path
  if err := doWork(); err != nil {
      return fmt.Errorf("work failed: %w", err)  // early return on error
  }
  finishWork()        // normal path at top level
  ```

- **[SHOULD]** Return errors or a separate status value rather than using “in-band” magic values to signal errors ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Go%E2%80%99s%20support%20for%20multiple%20return,be%20the%20final%20return%20value)) ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=And%20encourages%20more%20robust%20and,readable%20code)). For example, a function that might fail **SHOULD** return an extra `error` or boolean rather than a special result like `-1` or `nil` to indicate failure. This avoids ambiguity and forces callers to handle the error explicitly.
  *Example:*

  ```go
  // Preferred: separate result and error/ok flag
  func Find(key string) (Value, bool) { … }
  if val, ok := Find("item"); !ok {
      return errors.New("item not found")
  }

  // Not preferred: in-band error signaling via special return
  func Find(key string) Value { … }
  // (caller might forget to check if return == zero value)
  ```

- **[SHOULD]** Provide additional context when returning or logging errors, to aid debugging. If propagating an error, wrap it using `%w` so that the original error can be unwrapped by callers ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Error%20strings%20should%20not%20be,not%20combined%20inside%20other%20messages)). For example: `return fmt.Errorf("cannot open config file: %w", err)` adds context while preserving the original error for inspection.

## Code Structure and Formatting

- **[SHOULD]** Organize import statements into groups: standard library packages first, then third-party packages, with a blank line separating groups ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Avoid%20renaming%20imports%20except%20to,specific%20import)) ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=)). This convention improves readability by clearly distinguishing built-in dependencies from external ones. Tools like `goimports` will do this automatically.
  *Example:*

  ```go
  import (
      "fmt"
      "net/http"
      "os"

      "github.com/gorilla/mux"
      "golang.org/x/sync/errgroup"
  )
  ```

- **[SHOULD]** Structure modules into packages to promote modularity and clarity. Avoid huge monolithic packages. If a package or `main` program becomes large or has multiple distinct responsibilities, split out **internal** helper packages. Use the Go `internal/` directory for packages that are not intended for public use ([Organizing a Go module - The Go Programming Language](https://go.dev/doc/modules/layout#:~:text=Larger%20packages%20or%20commands%20may,for%20a%20package%20is%20thus)) ([Organizing a Go module - The Go Programming Language](https://go.dev/doc/modules/layout#:~:text=a%20directory%20named%20,for%20a%20package%20is%20thus)). Code under `internal/` **MUST NOT** be imported by external modules, which lets you refactor implementation details freely without breaking clients.

- **[MUST]** Use clear, single-purpose package boundaries. A package should have a cohesive responsibility. **MUST NOT** create miscellaneous utility packages named "`utils`" or "`common`" that gather unrelated functions; instead group code by feature or domain. This aligns with Go's philosophy of small, focused packages and helps maintain **Separation of Concerns**.

- **[MUST]** Write package documentation and comments for any exported function, type, or package-level variable/constant. Package comments (in a `doc.go` or at top of file) **SHOULD** provide an overview of the package’s purpose. Each exported item’s comment **MUST** form a complete sentence that begins with the item’s name ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=See%20https%3A%2F%2Fgo.dev%2Fdoc%2Feffective_go,and%20end%20in%20a%20period)), so that godoc renders it properly.
  *Example:*

  ```go
  // Encoder writes data in XYZ format.
  type Encoder struct { … }
  ```

## Naming and API Design

- **[MUST]** Name packages using short, lowercase, and evocative names ([Effective Go - The Go Programming Language](https://go.dev/doc/effective_go#:~:text=the%20importing%20package%20can%20talk,collision%20the%20importing%20package%20can)). **Do not** use underscores, hyphens, or mixedCaps in package names. The package name should ideally be one word (e.g. `strings`, `http`, `client`) and should reflect its intent. Because packages are referenced by import path, avoid redundant prefixes. For example, if your module path is `example.com/dbutil`, the package name should just be `dbutil` (not `db_util` or `dbUtil`).

- **[MUST]** Avoid stutter in naming identifiers. Since the imported package name provides context, omit repetitive prefixes in exported names ([Effective Go - The Go Programming Language](https://go.dev/doc/effective_go#:~:text=package%20they%20are%20testing%2C%20but,Use%20the%20package)). For instance, if package `metrics` has a struct for counters, name it `Counter` instead of `MetricsCounter` (client code will use it as `metrics.Counter` which is sufficiently clear). Similarly, **SHOULD NOT** repeat the package name in function names within that package ([styleguide | Style guides for Google-originated open-source projects](https://google.github.io/styleguide/go/best-practices.html#:~:text=,the%20name%20of%20the%20package)).
  *Example:* `ring.New()` is preferable to `ring.NewRing()` because the package name already conveys the type ([Effective Go - The Go Programming Language](https://go.dev/doc/effective_go#:~:text=package%20they%20are%20testing%2C%20but,Use%20the%20package)).

- **[MUST NOT]** use the blank import alias `import .` except in the very rare case of writing test files that need to pretend to be part of another package (to avoid circular dependencies) ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=,)). Outside of that scenario, importing a package with `.` pollutes the namespace and makes it unclear which package identifiers are coming from, harming readability.

- **[SHOULD]** Choose **idiomatic names** for Go identifiers:
  - **Receiver Names:** Method receivers should usually be a one- or two-letter abbreviation of the type name (e.g. `c` or `cl` for a `Client`) ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=The%20name%20of%20a%20method%E2%80%99s,call%20the%20receiver%20%E2%80%9Cc%E2%80%9D%20in)). **MUST NOT** use generic OOP-style names like `this` or `self` for receivers ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=The%20name%20of%20a%20method%E2%80%99s,call%20the%20receiver%20%E2%80%9Cc%E2%80%9D%20in)). Keep receiver names consistent within a type (don’t use `c` for some methods and `client` for others).
  - **Variable Names:** Prefer short names for limited-scope variables. For example, loop indices can be `i`, an `io.Reader` can be `r`. Longer names are appropriate for global or struct-level fields or when needed for clarity ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Variable%20names%20in%20Go%20should,sliceIndex)). As a guideline, the farther from its declaration a variable is used, the more descriptive its name should be ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Variable%20names%20in%20Go%20should,sliceIndex)).
  - **Constant Names:** Use CamelCase for constants. For acronyms in any name, consistently use either all capitals or all lowercase for the acronym part ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Words%20in%20names%20that%20are,for%20example%20%E2%80%9CxmlHTTPRequest%E2%80%9D%20or%20%E2%80%9CXMLHTTPRequest%E2%80%9D)). For instance, use `HTTPServer` or `httpServer` rather than `HttpServer` (mixed case acronyms) ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Words%20in%20names%20that%20are,for%20example%20%E2%80%9CxmlHTTPRequest%E2%80%9D%20or%20%E2%80%9CXMLHTTPRequest%E2%80%9D)). Similarly, write “ID” instead of “Id” in names ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=This%20rule%20also%20applies%20to,write%20%E2%80%9CappID%E2%80%9D%20instead%20of%20%E2%80%9CappId%E2%80%9D)). (Exported names must still begin with uppercase, so e.g. `GetHTTPURL` would be `GetHTTPURL` not `GetHttpUrl`.)

- **[SHOULD]** Name getter methods by the thing they return, not with a `Get` prefix ([Effective Go - The Go Programming Language](https://go.dev/doc/effective_go#:~:text=Go%20doesn%27t%20provide%20automatic%20support,names%20read%20well%20in%20practice)). For example, if a struct has an `owner` field, expose it with method `Owner()` rather than `GetOwner()` ([Effective Go - The Go Programming Language](https://go.dev/doc/effective_go#:~:text=Go%20doesn%27t%20provide%20automatic%20support,names%20read%20well%20in%20practice)). Go code tends to be concise, and the context makes it clear it's a getter. (An exception is when a getter is needed to distinguish from a field of the same name, but in idiomatic code fields are unexported so this is rarely an issue.)

- **[SHOULD]** Design interfaces with care:
  - **Interface Naming:** One-method interfaces are typically named with an **-er** suffix that reflects the method, e.g. `Reader` for something with a `Read()` method ([Effective Go - The Go Programming Language](https://go.dev/doc/effective_go#:~:text=Interface%20names)). Follow common Go conventions for well-known behaviors – for instance, an interface with a `Close()` method should be called `io.Closer`, not `io.CloseInterface`. Avoid giving your types method names that clash with standard meanings unless they fulfill the same contract ([Effective Go - The Go Programming Language](https://go.dev/doc/effective_go#:~:text=By%20convention%2C%20one,etc)) (e.g., don’t define a `Close()` method that doesn’t actually release resources).
  - **Defining Interfaces:** **MUST** define interfaces on the consumer side of an API, not the implementation side ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Go%20interfaces%20generally%20belong%20in,implementations%20without%20requiring%20extensive%20refactoring)). In practice, that means accept interfaces in your functions or methods if needed, but return concrete types. This allows you to add methods to your returned types without breaking callers ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Go%20interfaces%20generally%20belong%20in,implementations%20without%20requiring%20extensive%20refactoring)). Do not define broad interfaces just for the sake of mocking; instead design your API so that it can be tested via its public surface (using real implementations or lightweight alternatives) ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Do%20not%20define%20interfaces%20on,API%20of%20the%20real%20implementation)).
  - **Interface Size:** Keep interfaces small. An interface in Go represents a set of capabilities; it’s often better to have several small focused interfaces than a single large one. Avoid “fat” interfaces that require implementing many methods. Clients can combine interfaces if needed.

- **[SHOULD]** Choose method receiver types appropriately:
  - Use a **pointer receiver** if the method needs to modify the receiver or if the receiver is a large struct (to avoid copying) ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=don%E2%80%99t%20use%20a%20pointer%20to,or%20when%20called%20from%20this)). For example, methods on a struct that holds mutable state or a sync.Mutex **MUST** have pointer receivers ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=don%E2%80%99t%20use%20a%20pointer%20to,or%20when%20called%20from%20this)).
  - Use a **value receiver** only if the receiver is a small, immutable value where copying is cheap (e.g. a struct like `time.Time` or a primitive type) ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=,or%20struct%20types%20for%20all)). Even then, when in doubt, a pointer receiver is usually safer ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Choosing%20whether%20to%20use%20a,Some%20useful%20guidelines)) ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=,doubt%2C%20use%20a%20pointer%20receiver)).
  - **MUST NOT** mix pointer and value receivers on the same type; all methods of a given struct type should have receivers of the same kind for consistency ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=,doubt%2C%20use%20a%20pointer%20receiver)) (the compiler will prevent calling a method with the wrong receiver type on a value, but consistency is important for clarity). If you find yourself needing both, it’s a sign the type’s API may need refactoring.

## Concurrency and Goroutines

- **[MUST]** Make the lifecycles of goroutines clear and controlled. Every goroutine you start should either finish on its own or be signaled to stop – leaking goroutines is a serious problem in long-running services ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=When%20you%20spawn%20goroutines%2C%20make,they%20exit)). **Document** the conditions under which goroutines exit if it’s not obvious from code ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Try%20to%20keep%20concurrent%20code,and%20why%20the%20goroutines%20exit)). For example, if you launch background worker goroutines, ensure they listen on a channel or context that will be closed or canceled when they should terminate.
  **Rationale:** Goroutines do not automatically garbage-collect even if unreachable; a blocked goroutine can hang around forever ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=When%20you%20spawn%20goroutines%2C%20make,they%20exit)). Uncontrolled goroutines can lead to memory leaks, contention on shared resources, or deadlocks over time.

- **[MUST]** Avoid scenarios where sending on a closed channel or reading from a shared variable without synchronization can occur – these lead to panics or data races ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=are%20unreachable)). Use proper synchronization (channels, mutexes, etc.) or confinement to a single goroutine for shared state. Always run `go test -race` (the race detector) on your test suite to catch data races in concurrent code.

- **[SHOULD]** Prefer **synchronous function APIs** over asynchronous ones for library code ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Prefer%20synchronous%20functions%20,over%20asynchronous%20ones)). That is, have functions return their results directly and complete their work before returning, rather than spawning goroutines internally or using callbacks. This makes it easier for callers to reason about execution and to handle errors. If a caller needs to run an operation concurrently, they can explicitly start a goroutine or use `errgroup` in their code. It is much harder for a caller to force a library function that starts hidden goroutines to execute in a single-threaded way, whereas running a synchronous function concurrently is trivial by wrapping the call in `go ...()` ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Synchronous%20functions%20keep%20goroutines%20localized,need%20for%20polling%20or%20synchronization)).

- **[SHOULD]** Use channels or other coordination primitives to safely communicate between goroutines. If multiple goroutines need to be stopped early (e.g. on a cancellation or error), **MUST** signal them via a channel close or a cancellation context. For example, closing a done channel is a broadcast signal that unblocks any goroutine waiting on it ([Go Concurrency Patterns: Pipelines and cancellation - The Go Programming Language](https://go.dev/blog/pipelines#:~:text=We%20need%20a%20way%20to,the%20element%20type%E2%80%99s%20zero%20value)). Coordinate via `select` on channels to handle cancellation signals. Do not rely on global flags or busy-wait loops for synchronization – use the native concurrency primitives for clarity and correctness.

- **[MUST]** Avoid launching “fire-and-forget” goroutines from libraries without giving the caller control. If a library function spawns background goroutines (e.g., for monitoring or housekeeping), it **MUST** provide a way to shut them down (for instance, by accepting a `context.Context` or returning a stop function) ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Try%20to%20keep%20concurrent%20code,and%20why%20the%20goroutines%20exit)). In long-running systems, uncontrolled background goroutines can accumulate and cause issues.

## Context Usage

- **[MUST]** Thread `context.Context` through your call stack in any long-lived request or operation. In server applications, incoming requests should start with a `Context` (e.g. `req.Context()` in an HTTP handler), and functions down the call chain **MUST** accept a `Context` parameter so that cancellations or timeouts can propagate ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=Incoming%20requests%20to%20a%20server,45%2C%20or%20WithValue)). **All** significant I/O operations or external calls should accept a `Context`. This consistency enables tooling (like static analysis) to verify that context is properly propagated ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=Programs%20that%20use%20Contexts%20should,tools%20to%20check%20context%20propagation)).

- **[MUST NOT]** store a `Context` inside a struct field for later use ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=Do%20not%20store%20Contexts%20inside,first%20parameter%2C%20typically%20named%20ctx)). Contexts are meant to be passed explicitly to each call. Keeping them in structs can lead to confusion about which context is in use and may cause use-after-expiration bugs. Instead, pass the `Context` as an argument to each function/method that needs it (always as the first parameter, conventionally named `ctx`) ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=Do%20not%20store%20Contexts%20inside,first%20parameter%2C%20typically%20named%20ctx)).

- **[MUST NOT]** pass a `nil` context to any function that requires a `Context` ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=Do%20not%20pass%20a%20nil,about%20which%20Context%20to%20use)). Even if the API allows `nil`, treat that as deprecated – always provide a real context. If you don’t have a meaningful context (for example in short-lived startup code or tests), use `context.TODO()` or `context.Background()` explicitly ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=Do%20not%20pass%20a%20nil,about%20which%20Context%20to%20use)). This makes the lack of context explicit and clear.

- **[MUST]** When you create a cancellable or timeout context (via `context.WithCancel`, `WithTimeout`, or `WithDeadline`), always call the cancel function in a `defer` when the context is no longer needed ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=The%20WithCancel%20%2C%20%2043%2C,flow%20paths)). Failing to call `cancel()` will **leak resources** (the context and any associated timers) until the parent context is canceled or the timeout fires ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=The%20WithCancel%20%2C%20%2043%2C,flow%20paths)). Even if you think the context will timeout naturally, defer the cancel to be safe.
  *Example:*

  ```go
  ctx, cancel := context.WithTimeout(parentCtx, 2*time.Second)
  defer cancel()  // ensure resources are freed, even if timeout occurs
  err := doRPC(ctx)
  …
  ```

- **[SHOULD]** Use `Context.Value` **only** for request-scoped data that transits process boundaries, not for passing optional arguments to functions ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=Use%20context%20Values%20only%20for,passing%20optional%20parameters%20to%20functions)). In practice, context values are best used sparingly (e.g. tracing IDs, authentication tokens). If you find yourself wanting to stuff many things into a context, refactor your function to accept those as explicit parameters. **MUST NOT** use context values to bypass proper API design; it reduces type safety and discoverability.

- **[MUST]** Honor context cancellation in all routines. For example, in an HTTP handler or a long-running loop, regularly check `ctx.Err()` or `<-ctx.Done()` and abort work if the context is canceled ([Go Concurrency Patterns: Context - The Go Programming Language](https://go.dev/blog/context#:~:text=functions%20should%20abandon%20their%20work,channel%20idiom%20in%20more%20detail)) ([Go Concurrency Patterns: Context - The Go Programming Language](https://go.dev/blog/context#:~:text=The%20,set%20timeouts%20for%20I%2FO%20operations)). This ensures that when a client disconnects or a timeout is reached, your code stops promptly, releasing resources. Many standard library calls (database queries, HTTP calls, etc.) have context-aware versions (like `QueryContext`, `Do(req.WithContext(ctx))`, etc.) – use them so that the work can be canceled if the context ends.

## Testing

- **[MUST]** Write tests that are deterministic and self-contained. Tests should not depend on external state (like specific machine settings or network availability) unless absolutely necessary. Use test doubles or temporary test data to control the environment.

- **[SHOULD]** Make test failures **useful**. A failing test's output should clearly explain what was expected and what went wrong ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Tests%20should%20fail%20with%20helpful,typical%20Go%20test%20fails%20like)). Prefer using `t.Errorf`/`t.Fatalf` with descriptive messages over plain `t.Fail()`. Include the inputs, the expected outcome, and the actual result in the message ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Tests%20should%20fail%20with%20helpful,typical%20Go%20test%20fails%20like)). Assume the person debugging a failure is not familiar with the code – provide enough context.
  *Example:*

  ```go
  if got != want {
      t.Fatalf("Max(%d, %d) = %d; want %d", a, b, got, want)
  }
  ```

- **[MUST]** Follow Go conventions for the order of actual vs. expected values in test messages. The typical pattern is `if got != want { t.Errorf("... got X, want Y") }` ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=if%20got%20%21%3D%20tt.want%20,more%20past%20this%20point)). Writing the message as “expected X, got Y” is discouraged in Go tests ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Note%20that%20the%20order%20here,Go%20does%20not)). Stick to the `got/want` phrasing to match common practice and avoid confusion.

- **[SHOULD]** Use *table-driven tests* for functions that have multiple scenarios or edge cases ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=If%20that%20seems%20like%20a,driven%20test)). A table-driven test is a single test function that iterates over a list of test cases (each with input and expected output), calling the function and verifying results for each. This avoids code duplication and makes it easy to add new cases. Use sub-tests (`t.Run`) with descriptive names for each table entry if a case needs isolated setup or to show up distinctly in test output.

- **[SHOULD]** Structure tests to pinpoint which scenario failed. If using helper functions in tests, ensure that a failing assertion can be traced to a specific test case. For example, wrap helper calls in `t.Run` with a descriptive name or have separate `TestXxx` functions for logically distinct scenarios ([Go Wiki: Go Code Review Comments - The Go Programming Language](https://go.dev/wiki/CodeReviewComments#:~:text=Another%20common%20technique%20to%20disambiguate,test%20fails%20with%20that%20name)). This way a failing test log will indicate which case failed.

- **[MUST]** Keep tests fast and idempotent. Tests should clean up any resources they use (files, goroutines, etc.) and should be able to run repeatedly yielding the same results. Tests that intermittently fail or hang are not acceptable in a continuous integration environment.

## Web Services (HTTP Backends)

- **[SHOULD]** Use Go’s standard library `net/http` package for web services by default, instead of adopting a heavy third-party web framework, *unless* you have a strong specific reason ([Routing Enhancements for Go 1.22 - The Go Programming Language](https://go.dev/blog/routing-enhancements#:~:text=We%20made%20these%20changes%20as,programs%20with%20advanced%20routing%20needs)). The standard library’s HTTP server is high-performance and idiomatic; it’s sufficient for most services. In fact, improvements in Go 1.22 have added common routing features (method matching, wildcards) to `net/http` to reduce the need for external routers ([Routing Enhancements for Go 1.22 - The Go Programming Language](https://go.dev/blog/routing-enhancements#:~:text=We%20made%20these%20changes%20as,programs%20with%20advanced%20routing%20needs)). Third-party frameworks can introduce unnecessary abstraction and dependencies – prefer the simplicity and clarity of the standard `http.Handler` approach.

- **[MUST]** Propagate request context and honor client cancellations in web handlers. The `*http.Request` provided to handlers has a `Context()` method – use it for any downstream calls (database queries, RPCs, etc.). If the client disconnects or cancels the request, that context will be canceled automatically ([Canceling in-progress operations - The Go Programming Language](https://go.dev/doc/database/cancel-operations#:~:text=context%20is%20automatically%20canceled%20as,took%20more%20than%20five%20seconds)), which should abort your ongoing operations to save resources. **Example:** use `req.Context()` when calling your database: `db.QueryContext(req.Context(), ...)`. This way, if the client goes away, the database query will stop early ([Canceling in-progress operations - The Go Programming Language](https://go.dev/doc/database/cancel-operations#:~:text=context%20is%20automatically%20canceled%20as,took%20more%20than%20five%20seconds)).

- **[MUST]** Set appropriate timeouts on your HTTP server and client calls. Configure `http.Server` timeouts (Read, Write, Idle) to reasonable values to avoid hanging connections. Likewise, when making outbound HTTP requests, use contexts or `http.Client` with timeouts. This prevents runaway requests from exhausting resources.

- **[SHOULD]** Use TLS and secure practices for any production web service. While beyond the scope of style, it’s worth noting: you **SHOULD** use `ListenAndServeTLS` or a TLS termination proxy to handle HTTPS, and **SHOULD NOT** disable security checks (like skipping TLS certificate verification) except in local testing.

- **[SHOULD]** Prefer middleware patterns over deeply nested handlers. For cross-cutting concerns like logging, authentication, or tracing, consider writing middleware that wraps `http.Handler`. This keeps each handler’s core logic focused on its primary task. You can chain middleware (or use a library for middleware chaining) but ensure the added layers remain understandable.

## Command-Line Tools (CLI)

- **[SHOULD]** Use the standard library `flag` package for simple command-line tools, and structure your `main` package clearly. For more complex CLI applications (especially those with multiple subcommands, like `kubectl` or `git` style CLIs), **consider using** the popular Cobra library ([GitHub - spf13/cobra: A Commander for modern Go CLI interactions](https://github.com/spf13/cobra#:~:text=Cobra%20is%20a%20library%20for,creating%20powerful%20modern%20CLI%20applications)) ([GitHub - spf13/cobra: A Commander for modern Go CLI interactions](https://github.com/spf13/cobra#:~:text=Cobra%20is%20a%20library%20providing,to%20git%20%26%20go%20tools)). Cobra provides a framework for organizing commands, parsing flags, and generating help text, and is used in many large Go projects (Kubernetes, Hugo, GitHub CLI, etc.) ([GitHub - spf13/cobra: A Commander for modern Go CLI interactions](https://github.com/spf13/cobra#:~:text=Cobra%20is%20a%20library%20for,creating%20powerful%20modern%20CLI%20applications)). Adopting Cobra can make your CLI more standard and easier to maintain.

- **[MUST]** Provide helpful `-h/--help` output for your CLI. Whether using `flag` or Cobra, ensure that running the program with `-h` prints usage information. Cobra automatically generates help for commands and flags ([GitHub - spf13/cobra: A Commander for modern Go CLI interactions](https://github.com/spf13/cobra#:~:text=Cobra%20provides%3A)), but you should fill in descriptive help messages for each command and flag. This is crucial for usability in a large organization where many users may run the tool.

- **[SHOULD]** Follow Unix conventions for CLI behavior:
  - Exit with status code 0 on success, non-zero on errors. Use `os.Exit` accordingly after `main` or rely on the `log.Fatal` / `flag` package which calls exit on failure.
  - Print errors to `stderr` (for example, via `fmt.Fprintf(os.Stderr, ...)` or `log.Printf`), and normal output to `stdout`. This allows users to redirect outputs properly.
  - Support the `--version` flag if applicable to print the tool version.

- **[SHOULD]** Keep CLI code in the `cmd/` directory (common convention) with one subdirectory per binary if your repository builds multiple binaries. For instance, `cmd/mytool/main.go` would import your packages and wire up flags. This keeps the `main` lightweight, deferring to library packages for the core logic, which aids testability (you can unit-test the logic in the package, separate from the CLI parsing).

- **[MAY]** Use high-level libraries for complex flag parsing if needed, but minimize external dependencies. Cobra is often sufficient since it wraps `pflag` (an enhanced version of `flag`). If you need strictly POSIX-compliant flags or more custom parsing, evaluate well-known libraries but weigh the cost of adding them.

## Kubernetes Controllers and Operators

- **[MUST]** Design Kubernetes controllers to be **level-triggered** and **idempotent** in their reconcile logic. The controller’s reconcile function will be called repeatedly for the same object, so it **MUST NOT** have side effects that aren’t repeatable. Ensure that applying the same desired state twice has the same result as once. This usually means checking the actual state via the Kubernetes API and only performing actions necessary to move toward the desired state. Reconcile functions should be safe to run multiple times even if the system hasn’t changed (they should quickly realize “nothing to do”). The Kubernetes documentation emphasizes that reconcilers need to be idempotent, since they are invoked until the desired state is achieved ([5.5 The Kubernetes Operator Metamodel - Kubernetes Operator Patterns and Best Practises Documentation](https://ibm.github.io/operator-sample-go-documentation/overview-the-k8s-operator-metamodel/#:~:text=nature%20of%20distributed%20Kubernetes%20systems,and%20gets%20events%20via%20filters)).

- **[MUST]** adhere to the principle “one controller per resource type.” Each controller (often one controller per CustomResourceDefinition kind) should manage a single type of resource ([5.5 The Kubernetes Operator Metamodel - Kubernetes Operator Patterns and Best Practises Documentation](https://ibm.github.io/operator-sample-go-documentation/overview-the-k8s-operator-metamodel/#:~:text=nature%20of%20distributed%20Kubernetes%20systems,and%20gets%20events%20via%20filters)). Do not write one controller to handle multiple unrelated CRD kinds in the same loop ([Good Practices - The Kubebuilder Book](https://book.kubebuilder.io/reference/good-practices#:~:text=%E2%80%98install_all_controller)) ([Good Practices - The Kubebuilder Book](https://book.kubebuilder.io/reference/good-practices#:~:text=,makes%20the%20system%20more%20robust)). Splitting controllers this way follows the Single Responsibility Principle and avoids complexity and interference between reconcilers. It also aligns with the design of the Kubernetes controller-runtime library and makes it easier to scale controllers (since you can run more instances of a specific controller if needed) ([Good Practices - The Kubebuilder Book](https://book.kubebuilder.io/reference/good-practices#:~:text=Avoid%20a%20design%20solution%20where,can%20lead%20to%20several%20issues)) ([Good Practices - The Kubebuilder Book](https://book.kubebuilder.io/reference/good-practices#:~:text=,CRs%20and%20an%20error%20occurs)).

- **[SHOULD]** Use the official controller libraries to build your controllers. The **controller-runtime** framework (part of the Kubebuilder project) is the recommended foundation for writing new controllers/operators ([GitHub - kubernetes-sigs/controller-runtime: Repo for the controller-runtime subproject of kubebuilder (sig-apimachinery)](https://github.com/kubernetes-sigs/controller-runtime#:~:text=Kubernetes%20controller)). It provides higher-level abstractions on top of client-go, such as controllers, managed workqueues, and predictive informers. By using controller-runtime (or a scaffolding tool like Kubebuilder or Operator SDK which builds on it ([GitHub - kubernetes-sigs/controller-runtime: Repo for the controller-runtime subproject of kubebuilder (sig-apimachinery)](https://github.com/kubernetes-sigs/controller-runtime#:~:text=The%20Kubernetes%20controller,how%20it%20can%20be%20used))), you benefit from Kubernetes API conventions and reduce boilerplate. This makes your operator code more maintainable and aligned with community best practices. (If writing a very simple controller, you may use client-go directly with informers, but be aware this is lower-level and requires handling more plumbing.)

- **[SHOULD]** Follow Kubernetes API conventions for custom resources. For example, implement **Status** sub-resources and use **Status Conditions** to convey the state of your CRs ([Good Practices - The Kubebuilder Book](https://book.kubebuilder.io/reference/good-practices#:~:text=Why%20You%20Should%20Adopt%20Status,Conditions)). Conditions (Ready, Progressing, etc.) are a standard, machine-readable way to report status and are encouraged in Kubernetes APIs ([Good Practices - The Kubebuilder Book](https://book.kubebuilder.io/reference/good-practices#:~:text=Why%20You%20Should%20Adopt%20Status,Conditions)). Also use standard fields like `.metadata.finalizers` for clean-up logic when deleting CRs (and remember to remove finalizers when done to avoid stuck resources). Adhering to these conventions makes your operator feel native and works well with Kubernetes tooling.

- **[MUST]** Handle errors and retries in controllers gracefully. The reconcile loop should return an error if it wants to requeue the request for retry. When using controller-runtime, returning an `error` or a special `Result{RequeueAfter: ...}` triggers the controller to requeue the reconcile (with exponential backoff on errors by default). **DO NOT** `panic` in reconciles; always return errors instead so the controller can decide to retry without crashing the process.

- **[MUST]** Use concurrency controls to avoid overwhelming the API server. For example, if your controller creates or updates many resources, consider rate-limiting those calls or batching where possible. The controller-runtime `Manager` by default limits the number of concurrent reconciles; configure this (via `MaxConcurrentReconciles`) appropriately based on your controller’s complexity and the cluster size. Too high concurrency can lead to contention or API throttling; too low can underutilize resources.

- **[SHOULD]** Write extensive tests for controllers. Since controllers embody complex logic and side effects, use **envtest** (from controller-runtime) or kind-based integration tests to run your reconcile logic against a real API server. Ensure your controller handles expected scenarios (create, update, delete events) and failure cases (API server errors, transient issues) robustly. Testing will also enforce that your reconcile is idempotent and behaves as expected.

(Technology-specific libraries and tools evolve quickly; the following sections reflect best practices as of 2025 and MAY become outdated – always refer to the latest official documentation for updates.)

## Logging and Metrics

- **[SHOULD]** Use **structured logging** for server applications. Instead of writing ad-hoc plain text logs, use key-value pairs that can be parsed and indexed. Go 1.21 introduced the `log/slog` package which provides structured, leveled logging as part of the standard library ([Structured Logging with slog - The Go Programming Language](https://go.dev/blog/slog#:~:text=The%20new%20,filter%20them%20quickly%20is%20essential)). Adopting `slog` (or a similar structured logger) is highly recommended for production code. It allows you to attach context fields (request IDs, user IDs, etc.) to log messages, making it far easier to filter and search logs. In large systems, this is essential for debugging ([Structured Logging with slog - The Go Programming Language](https://go.dev/blog/slog#:~:text=The%20new%20,filter%20them%20quickly%20is%20essential)).

- **[SHOULD]** Prefer the standard library’s `log/slog` for new projects to avoid dependency bloat. Many third-party logging libraries exist (zap, logrus, etc.), but having multiple logging systems in one binary is problematic for consistency ([Structured Logging with slog - The Go Programming Language](https://go.dev/blog/slog#:~:text=quite%20popular%3A%20one%20of%20the,in%20over%20100%2C000%20other%20packages)). By using `log/slog`, you provide a common framework that other libraries can share, and you reduce the risk of conflicting logging formats ([Structured Logging with slog - The Go Programming Language](https://go.dev/blog/slog#:~:text=quite%20popular%3A%20one%20of%20the,in%20over%20100%2C000%20other%20packages)). The Go team created `slog` to unify structured logging needs in one place. (If you have an existing project using a different structured logger, you may not switch immediately, but plan to converge on one logging system.)

- **[MUST]** Never log sensitive information. Even though this is more about security than style: ensure that logs do not contain passwords, API keys, or personal data that shouldn’t be persisted. This is especially important in structured logs which might be ingested into analytics systems. Use filtering and redaction where appropriate.

- **[MAY]** Use logging **levels** (Info, Debug, Warn, Error) appropriately to control verbosity. With `slog`, you can set a level on the handler. **SHOULD NOT** overload INFO with excessive debug data; use DEBUG level for that and run it only when debugging issues. Likewise, treat ERROR level seriously (something the operator should look at). `slog` supports leveled logging out of the box ([Go 1.21 Release Notes - The Go Programming Language](https://tip.golang.org/doc/go1.21#:~:text=Go%201.21%20Release%20Notes%20,processing%20of%20large%20amounts)).

- **[SHOULD]** Include enough context in log messages to be actionable. For example, include request identifiers, resource names, or user identifiers when logging events in a server. In `slog`, you can do `logger.Info("failed to process item", "itemID", id, "retry", retryCount)` to attach context. This is far more useful than just `logger.Info("failed to process item")`. Strive for logs that aid post-mortem analysis.

- **[MAY]** Use metrics (with Prometheus, StatsD, etc.) alongside logs for visibility. This falls under operational best practices: logs are great for discrete events and debugging, while metrics capture trends. Expose metrics for critical operations (like number of errors, request latencies, queue lengths) using `prometheus/client_golang` or a similar library. This complements logging by providing a higher-level overview of system health.

## Linting and Static Analysis

- **[MUST]** Run **static analysis** tools as part of your development and CI process. Go’s built-in `go vet` tool identifies many common mistakes (like unchecked format verbs, misuse of `goroutine` when copying locks, etc.) and **MUST** be clean for all code committed. Additionally, use a comprehensive linter tool like **golangci-lint** to catch style issues, potential bugs, and anti-patterns. GolangCI-Lint aggregates over a hundred linters (inefficiency, dead code, misspellings, etc.) and runs them in parallel ([Introduction | golangci-lint](https://golangci-lint.run/#:~:text=Golangci,runner%20for%20Go)), providing a one-stop check. Enforce that code passes linting to maintain a high baseline quality.

- **[SHOULD]** Use consistent linter configurations across projects. For example, enable linters such as `govet` (built-in vet checks), `ineffassign` (ineffective assignments), `staticcheck` (robust static analysis), `golint` or `revive` (style suggestions), `goconst` (duplicate constants), `gocyclo` (complexity), etc. Adjust the configuration by enabling/disabling specific linters to match your team's agreed style. The key is to automate style enforcement so code reviews can focus on design rather than nits.

- **[SHOULD]** Treat linter warnings as actionable. Strive to have zero warnings from the linter. If a particular rule is not applicable, it's better to disable that linter or annotate the code to ignore it than to let warnings pile up. This keeps the signal-to-noise ratio of your tooling high.

- **[MAY]** Augment linting with additional static analysis tools for security and performance. For example, consider using **gosec** to scan for common security issues (SQL injection, weak cryptography usage) as part of CI. For performance, tools like `go tool pprof` and `go test -bench` can be used, though not strictly static analysis. The goal is to catch issues early – the compiler and linters are your first line of defense.

- **[MUST]** Maintain your tooling over time. As Go releases evolve, update golangci-lint and other tools to their latest versions periodically. New Go language features might introduce new lint rules or vet checks. For instance, as of Go 1.20+, some patterns get flagged differently than in earlier versions. Keep an eye on official release notes for `go vet` and adjust your code or config accordingly ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=the%20parent%20is%20canceled,flow%20paths)). High code quality is an ongoing effort.

## References

- Go Official Blog and Documentation (Go Team) – Effective Go, Code Review Comments, Go Blog posts on specific topics (errors, context, logging, etc.) ([Effective Go - The Go Programming Language](https://go.dev/doc/effective_go#:~:text=Occasionally%20you%27ll%20see%20code%20that,they%27re%20provided%20for%20a%20reason)) ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=Do%20not%20store%20Contexts%20inside,first%20parameter%2C%20typically%20named%20ctx))
- Official Go Packages Documentation (go.dev) – e.g. `context` package guidelines ([context package - context - Go Packages](https://pkg.go.dev/context#:~:text=Do%20not%20pass%20a%20nil,about%20which%20Context%20to%20use)), `net/http` updates ([Routing Enhancements for Go 1.22 - The Go Programming Language](https://go.dev/blog/routing-enhancements#:~:text=We%20made%20these%20changes%20as,programs%20with%20advanced%20routing%20needs))
- Kubernetes Documentation and Kubebuilder Book – Best practices for controllers and operators ([5.5 The Kubernetes Operator Metamodel - Kubernetes Operator Patterns and Best Practises Documentation](https://ibm.github.io/operator-sample-go-documentation/overview-the-k8s-operator-metamodel/#:~:text=nature%20of%20distributed%20Kubernetes%20systems,and%20gets%20events%20via%20filters)) ([Good Practices - The Kubebuilder Book](https://book.kubebuilder.io/reference/good-practices#:~:text=%E2%80%98install_all_controller))
- GitHub Repositories (official) – e.g. GolangCI-Lint, Cobra, controller-runtime (for tool-specific guidance) ([GitHub - spf13/cobra: A Commander for modern Go CLI interactions](https://github.com/spf13/cobra#:~:text=Cobra%20is%20a%20library%20for,creating%20powerful%20modern%20CLI%20applications)) ([GitHub - kubernetes-sigs/controller-runtime: Repo for the controller-runtime subproject of kubebuilder (sig-apimachinery)](https://github.com/kubernetes-sigs/controller-runtime#:~:text=Kubernetes%20controller))

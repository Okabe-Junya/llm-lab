# Go 実装ベストプラクティス・スタイルガイド

**注意：** このガイドでは、**RFC 2119** および **RFC 8174** のキーワード（MUST、MUST NOT、SHOULD、SHOULD NOT、MAY）を使用して各ルールの遵守レベルを示しています。これはプロダクションコードを書く中堅〜上級のGoエンジニアを対象とし、大規模コードベースにおける一貫性、明確性、保守性を重視しています。

---

## エラーハンドリング

- **[MUST]** 関数から返されたエラーは必ず確認して処理すること。`_`に代入するなどしてエラーを無視してはならない。エラーを返す関数では、成功を確認したうえで、エラーを処理する・呼び出し元に返す・または（本当に例外的なケースで）`panic`を発生させる必要がある。

- **[MUST NOT]** 通常のエラーや想定される失敗に `panic` を使ってはならない。`panic` は回復不能な条件やバグのみに用いること。例えばパース失敗などは、エラーを返すべきであり、`panic` してはならない。

- **[MUST]** エラーメッセージは簡潔かつ有益な内容で、小文字から始め、終止符（ピリオド）はつけないこと。例: `fmt.Errorf("failed to load config")`（× `Failed to load config.`）

- **[SHOULD]** エラー処理には早期リターン（early return）を使って、正常系の処理がインデントされないようにすること。これにより可読性が高まる。

- **[SHOULD]** エラーを示すために `-1` や `nil` などの「インバンド」なマジック値を使うのではなく、明示的に `error` や `bool` などの別の戻り値を使うこと。

- **[SHOULD]** エラーを返す際は、文脈情報を付加してデバッグを助けること。エラーのラップには `%w` を用いる。

---

## コード構造と整形

- **[SHOULD]** import文は、標準ライブラリ→サードパーティの順でグループ分けし、空行で区切る。

- **[SHOULD]** モジュールは明確な責務を持つパッケージに分けること。巨大な monolithic パッケージは避け、`internal/` ディレクトリは外部に公開しない内部実装に使う。

- **[MUST]** `utils` や `common` のような役割が曖昧なパッケージ名を使わず、機能単位で明確に名前を付けること。

- **[MUST]** パッケージのドキュメントコメントを書くこと。エクスポートされる関数・型・定数には、必ず名前から始まる完全な文のコメントを付ける。

---

## 名前付けとAPI設計

- **[MUST]** パッケージ名は短く、小文字で意味を持つ名前にすること。アンダースコアや大文字混じりは禁止。

- **[MUST]** パッケージ名と識別子名で繰り返し（stutter）を避ける。例えば `metrics.Counter` として使用されるので、`MetricsCounter` のように冗長にしないこと。

- **[MUST NOT]** `import .` はテストなどの特殊な場面を除き使用してはならない。名前空間を汚染し、可読性を損なう。

- **[SHOULD]** 命名はGoの慣例に従うこと：
  - レシーバ名は型の略称（例: `Client`なら`c`や`cl`）
  - 変数名はスコープに応じて短く、分かりやすく
  - 定数はCamelCase。略語（例: HTTP, ID）は大文字に統一

- **[SHOULD]** Getter関数に `Get` を付けるのは避け、返す対象の名前にする（例: `Owner()`）

- **[SHOULD]** インターフェースの設計には以下を従う：
  - 名前は `Reader` のように `-er` 接尾辞
  - インターフェースは利用側に定義する
  - インターフェースは小さく保つ（fat interface は避ける）

- **[SHOULD]** レシーバの型は以下の基準で選ぶ：
  - ポインタレシーバ：構造体が大きい、または状態を変更する場合
  - 値レシーバ：構造体が小さく、イミュータブルな場合のみ
  - 同じ型でポインタと値レシーバを混在させないこと

---

## 並行処理とGoroutine

- **[MUST]** Goroutine のライフサイクルは明確に制御されなければならない。終了条件をコードまたはコメントで明記する。

- **[MUST]** クローズされたチャネルへの送信、同期なしの変数アクセスは避け、同期手段（チャネルやミューテックス）を使う。`go test -race` を活用する。

- **[SHOULD]** ライブラリでは非同期APIより同期APIを好むこと。呼び出し元が明示的にGoroutineを使うべきである。

- **[SHOULD]** Goroutine間の通信はチャネルなどのプリミティブを使って安全に行うこと。キャンセルはチャネルやContextで伝達する。

- **[MUST]** ライブラリ内での「投げっぱなしGoroutine」は禁止。キャンセル手段（`context.Context`やstop関数）を提供すること。

---

## Contextの使用

- **[MUST]** 長寿命なリクエストや操作では `context.Context` を呼び出し階層全体に通すこと。関数の第一引数として受け取り、適切に伝搬させること。

- **[MUST NOT]** Contextを構造体のフィールドに保存してはならない。

- **[MUST NOT]** `nil` Context を関数に渡してはならない。代わりに `context.TODO()` や `context.Background()` を使用する。

- **[MUST]** `WithCancel` 等で生成した cancel 関数は必ず `defer` で呼び出すこと。

- **[SHOULD]** `Context.Value` はトレースIDや認証トークンなど、プロセス境界を越える必要のあるリクエストスコープの値に限定すること。

- **[MUST]** Contextのキャンセルは常に尊重し、適時中断処理を行うこと。

---

## テスト

- **[MUST]** テストは決定的で自己完結的でなければならない。外部状態（特定のマシン設定やネットワーク可用性など）に依存してはならない。必要に応じてテストダブルや一時データを使い、環境を制御すること。

- **[SHOULD]** テストが失敗した場合、その出力は何が期待されていて何が起きたのかを明確に伝えるべきである。`t.Errorf` や `t.Fatalf` を使い、入力・期待値・実際の出力を含めた説明を記述すること。

  例:

  ```go
  if got != want {
      t.Fatalf("Max(%d, %d) = %d; want %d", a, b, got, want)
  }
  ```

- **[MUST]** Go におけるテストメッセージでは、`got != want` の順で比較し、「got X, want Y」の形式を守ること。これはGoにおける慣例であり、「expected X, got Y」のような書き方は避ける。

- **[SHOULD]** 複数のケースや端ケースがある関数に対しては、テーブル駆動テスト（table-driven test）を使うこと。各ケースに対してサブテスト (`t.Run`) を用いると、出力の識別がしやすくなる。

- **[SHOULD]** どのテストケースが失敗したのかが特定できるよう、テストを構造化すること。ヘルパー関数内での失敗でもどのケースか分かるように、`t.Run` でラップしたり、ケースごとに別々の `TestXxx` 関数を作るなどの工夫を行う。

- **[MUST]** テストは高速かつ再実行可能（冪等）でなければならない。テストが使ったリソース（ファイルや Goroutine など）はすべてクリーンアップし、何度実行しても同じ結果になるようにすること。CI環境では不安定なテストは許容されない。

---

## Webサービス（HTTPバックエンド）

- **[SHOULD]** Webサービスにはデフォルトで Go 標準の `net/http` パッケージを使用すること。特別な理由がない限り、重厚なサードパーティフレームワークを導入すべきではない。Go 1.22 ではルーティング機能も強化されており、多くの用途に十分である。

- **[MUST]** Webハンドラ内ではリクエストコンテキスト（`*http.Request.Context()`）を下位処理にも伝搬し、キャンセルを尊重すること。クライアントが接続を切断すれば、このコンテキストは自動でキャンセルされ、下流の処理（DBクエリ等）も中止できる。

- **[MUST]** HTTPサーバとクライアント呼び出しには適切なタイムアウトを設定すること。`http.Server` の Read, Write, Idle タイムアウト、また `http.Client` による呼び出し時のコンテキスト・タイムアウトを必ず設定する。

- **[SHOULD]** 本番環境のWebサービスではTLSとセキュアな設定を使用すること。HTTPSには `ListenAndServeTLS` や TLS終端プロキシを使い、証明書検証の無効化（特に `InsecureSkipVerify`）はローカル開発環境以外では避ける。

- **[SHOULD]** ハンドラを深くネストさせるより、ミドルウェアパターンを使うこと。ログ出力・認証・トレーシングなどの共通処理は `http.Handler` をラップする形で構成し、ハンドラ本体の責務を明確に保つ。

---

## コマンドラインツール（CLI）

- **[SHOULD]** 単純なCLIツールには標準ライブラリの `flag` パッケージを使用し、`main` パッケージを明確に構造化すること。複雑なCLI（サブコマンドを持つ `kubectl` や `git` スタイル）は、Cobra ライブラリの使用を検討すること。

- **[MUST]** CLIツールには `-h` / `--help` オプションを必ず用意し、実行時に使用法が表示されるようにする。Cobra は自動的にヘルプを生成するが、各コマンドやフラグには適切な説明文をつける必要がある。

- **[SHOULD]** CLIの動作にはUNIXの慣習に従う：
  - 成功時は終了コード0、エラー時は非0を返す。
  - 標準出力（stdout）と標準エラー出力（stderr）を使い分ける。
  - バージョン表示用に `--version` フラグを提供する。

- **[SHOULD]** CLIのコードは `cmd/` ディレクトリに格納し、バイナリごとにサブディレクトリを分ける（例: `cmd/mytool/main.go`）。コアロジックはライブラリパッケージに委譲し、`main` は軽量に保つ。

- **[MAY]** 高度なフラグ解析が必要な場合、外部ライブラリの使用を検討してもよいが、依存は最小限にすること。Cobraは通常は十分である。

---

## Kubernetes コントローラーとオペレーター

- **[MUST]** Kubernetes コントローラーは、**level-triggered** かつ **冪等** なreconcileロジックを持つように設計しなければならない。reconcile loopは同じオブジェクトに対して何度も呼ばれるため、繰り返しても同じ結果になるように実装する必要がある。現在の状態を Kubernetes API を通じて確認し、必要な場合にのみ操作を行うこと。同じ目的の再調整が複数回呼ばれても、動作に副作用が出ないようにする。

- **[MUST]** 「リソースタイプごとに1つのコントローラー」という原則に従うこと。つまり、1つのコントローラーが複数の異なる種類のCRD（CustomResourceDefinition）を扱うべきではない。責務の分離を守ることで、コードの見通しや保守性が向上し、スケーラビリティも確保できる。

- **[SHOULD]** コントローラーを構築する際は、公式の controller ライブラリを使用すること。特に **controller-runtime**（Kubebuilderプロジェクトの一部）が推奨される。このライブラリは client-go 上に高レベルな抽象化（コントローラー、ワークキュー、インフォーマーなど）を提供しており、Boilerplate を減らせる。必要に応じて Kubebuilder や Operator SDK などのスキャフォールディングツールの使用も検討する。

- **[SHOULD]** カスタムリソースを定義する際は、Kubernetes API の慣習に従うこと。例えば `.status` サブリソースや **Status Conditions**（例: `Ready`, `Progressing` など）を使ってリソースの状態を明示する。また、削除時のクリーンアップには `.metadata.finalizers` を使い、完了後は必ずファイナライザを削除すること。

- **[MUST]** コントローラー内ではエラーやリトライを適切に扱うこと。再調整関数でエラーを返すことで、再実行がトリガーされる。`controller-runtime` を使っている場合、`error` を返すか `Result{RequeueAfter: ...}` を返すことで再調整が行われる。**決して `panic` を使ってはならない**。

- **[MUST]** APIサーバへの過剰な負荷を避けるため、コントローラーには並列度制御を設けること。大量のリソースを作成・更新する場合は、rate-limit やバッチ処理を考慮する。`controller-runtime` の `Manager` では `MaxConcurrentReconciles` を設定して調整できる。

- **[SHOULD]** コントローラーには十分なテストを書くこと。特に **envtest** や kind を使った統合テストで、再調整ロジックが正しく動作するか、APIサーバと正しく連携するかを確認すること。再調整処理が冪等であることもテストで確認する。

---

## ロギングとメトリクス

- **[SHOULD]** サーバーアプリケーションでは**構造化ログ**を使うこと。プレーンなテキストログではなく、キー・バリュー形式で出力することで、解析やインデックス化が容易になる。Go 1.21 では `log/slog` パッケージが導入され、標準ライブラリで構造化・レベル付きロギングが可能になった。

- **[SHOULD]** 新規プロジェクトでは標準の `log/slog` を使うことを推奨する。ログライブラリが乱立するとフォーマットが統一されず混乱を招く。`slog` を使えば、ライブラリ間でログ基盤を共有でき、フォーマットの一貫性も保てる。

- **[MUST]** パスワード、APIキー、個人情報などの**機密情報をログに出力してはならない**。構造化ログは分析システムに流れることが多いため、フィルタリング・マスキングの対策が必要である。

- **[MAY]** ログレベル（Info, Debug, Warn, Error）を適切に使い分けること。詳細なデバッグ情報は Debug レベルに限定し、通常は出力しない。Error レベルはオペレーターが対処すべき深刻な事象に限定する。

- **[SHOULD]** ログには十分なコンテキスト（リクエストIDやユーザーID、リソース名など）を含めること。例: `logger.Info("failed to process item", "itemID", id, "retry", retryCount)` のように。

- **[MAY]** 可観測性を高めるため、ログに加えてメトリクス（Prometheus, StatsD など）も併用すること。ログはイベントの記録に、メトリクスは傾向や異常検知に向いている。重要な処理にはエラー数やレイテンシなどのメトリクスを導入すること。

---

## リンティングと静的解析

- **[MUST]** 静的解析ツールを開発・CIプロセスの一部として必ず実行すること。Go組み込みの `go vet` は一般的なミス（フォーマット指定子の誤りや Goroutine の誤用など）を検出でき、**常にエラーゼロ**を維持すべきである。

- **[SHOULD]** 包括的なリンターツール（例: **golangci-lint**）を導入して、スタイル・バグ・アンチパターンなどを自動検出すること。golangci-lint は100以上のリンターを並列実行し、コード品質を一括でチェックできる。

- **[SHOULD]** 複数プロジェクトでリンターの設定を統一すること。例えば `govet`, `ineffassign`, `staticcheck`, `revive`, `goconst`, `gocyclo` などを適切に組み合わせて設定する。チームで合意したルールに従い、自動化によってレビュアーの負担を減らす。

- **[SHOULD]** リンターの警告は常にアクション可能であるべき。適用できないルールはオフにするか、明示的にコメントで無視する。警告が積もると本当に重要な警告を見逃す可能性がある。

- **[MAY]** セキュリティやパフォーマンス向上のために追加の静的解析ツールを使うのもよい。たとえば **gosec** によるセキュリティチェック（SQLインジェクション、暗号の誤用など）や、`go test -bench` や `pprof` による性能解析など。

- **[MUST]** ツール類は定期的にアップデートすること。Go のバージョンアップに伴って `go vet` やリンターのルールも変化するため、最新の公式ドキュメントやリリースノートに目を通し、コードや設定を適宜見直す。

---

## 参考文献

- Go公式ブログおよびドキュメント（Goチームによる）
  [Effective Go](https://go.dev/doc/effective_go)
  [Go Wiki: Code Review Comments](https://go.dev/wiki/CodeReviewComments)

- Go標準パッケージドキュメント
  [`context` パッケージ](https://pkg.go.dev/context)
  [`net/http` のアップデート](https://go.dev/blog/routing-enhancements)

- Kubernetes公式ドキュメントおよびKubebuilder Book
  [Kubernetes Operator Metamodel](https://ibm.github.io/operator-sample-go-documentation/overview-the-k8s-operator-metamodel)
  [Good Practices - The Kubebuilder Book](https://book.kubebuilder.io/reference/good-practices)

- GitHubの公式リポジトリ（ツール固有の参考）
  [Cobra](https://github.com/spf13/cobra)
  [controller-runtime](https://github.com/kubernetes-sigs/controller-runtime)
  [golangci-lint](https://github.com/golangci/golangci-lint)
